## 1.数据库基本概念

![image-20240914093528632](https://s2.loli.net/2024/09/18/7eso9J32DwvXF8k.png)

### 考点1：数据库系统体系结构

集中式数据库系统

* 数据是集中的
* 数据管理是集中的

C/S结构

* 客户端负责数据表示服务
* 服务器负责数据库服务
* 数据库系统分为前后端
* ODBC, JDBC

分布式数据库

* 物理上分布，逻辑上集中
* 物理上分布，逻辑上分布
* 特点
* 透明性

并行数据库（了解

* 共享内存式
* 无共享式



#### 分布式数据库特点（可用性重点）

![image-20240914094420699](https://s2.loli.net/2024/09/18/gcOhY83PDltqKe2.png)

#### 分布式数据库透明性

![image-20240914094620710](C:\Users\Mrliu\AppData\Roaming\Typora\typora-user-images\image-20240914094620710.png)

![image-20240914094701356](C:\Users\Mrliu\AppData\Roaming\Typora\typora-user-images\image-20240914094701356.png)

>  DA 分块对应分片

![image-20240914094848370](https://s2.loli.net/2024/09/14/KUVN7SZdGjRcCHQ.png)

系统瘫痪 ————可用性



### 考点2：三级模式结构

**三级模式和两级映像**

![image-20240914100617850](C:\Users\Mrliu\AppData\Roaming\Typora\typora-user-images\image-20240914100617850.png)

* 内模式——存储模式
* 外模式——用户模式
* 概念模式——模式（基本表）
* 对外给视图，修改映射关系，可以保证应用的调用
* 逻辑独立性——数据的逻辑结构发生变化后，用户程序也可以不修改，但是为了保证应用程序能够正确执行，需要修改外模式和概念模式之间的映像。
* 物理独立性——当数据的物理结构发生改变时（换磁盘），英勇程序不用改变。但是为了能够保证应用程序能够正确执行，需要修改概念模式和内模式之间的映像。

![image-20240920115756118](https://s2.loli.net/2024/09/20/qYVadbDmRGQhWz1.png)

> B

![image-20240920115856723](https://s2.loli.net/2024/09/20/naDEKcbxm3GzpRO.png)

> B

![image-20240920120107653](https://s2.loli.net/2024/09/20/i7fdgVDoJIuTLSv.png)

> D



### 考点3：数据仓库

![image-20240920120528330](https://s2.loli.net/2024/09/20/tMes2uF6WxUzSBl.png)

阶段1：数据预处理（ETL）

阶段2：数据仓库存储

阶段3：数据分析

阶段4：数据展现

![image-20240920120755531](https://s2.loli.net/2024/09/20/JbUCSytN8fWwoAs.png)

> 数据仓库属于OLAP（联机分析），不属于OLTP（联机事务，数据库）

![image-20240920120933220](https://s2.loli.net/2024/09/20/e9yjAPb6tl18EWh.png)

> B  多**维度**分析
>
> A数据清理
>
> C联机事务
>
> D数据抽取过程



## 2.数据库设计过程  

> 1分左右，下午题可能会出

![image-20240920121635407](https://s2.loli.net/2024/09/20/c7wYOPruszZUCSq.png)

* 数据流图——DFD
* 数据字典——DD
* 第一层抽象——ER模型
* 需求分析，概念结构设计，逻辑结构设计的产物
* 物理设计——聚覆索引

![image-20240920122303900](https://s2.loli.net/2024/09/20/zwiFDru7kPOtLoy.png)

> C
>
> - **A需求分析**：这个阶段主要是确定系统需要做什么，包括用户的需求和系统的功能需求。
> - **B概念设计**：在这个阶段，设计者会创建一个独立于具体数据库实现的概念模型，如实体-关系图（ER图）。
> - **C逻辑设计**：如上所述，是规范化过程发生的阶段。
> - **D物理设计**：这个阶段涉及到为特定DBMS实现选择存储结构、存取路径等物理层面的细节。



## 3.概念设计阶段

### 考点1：概念设计过程

![image-20240920150450850](https://s2.loli.net/2024/09/20/fMl2HRD6Aqsm9yt.png)

> 注意是同一对象





### 考点2：E-R图（下午题）

![image-20240920161208264](https://s2.loli.net/2024/09/20/uaNIsjRdLnUrKCJ.png)

![image-20240920162046125](https://s2.loli.net/2024/09/20/yvIfN4BgVdAwO3e.png)

![image-20240920162524377](https://s2.loli.net/2024/09/20/jdYnSL7c4EamZ6r.png)

### 联系类型

#### 不同实体集之间的联系

![image-20240920163130705](https://s2.loli.net/2024/09/20/d7uMCnGo4t2ZNse.png)

* 一对多分为两种：一对多，多对一

两个以上不同实体集之间的联系（三元联系）多重度的确定（可根据语义直接转换）

以三元关系中的一个实体作为中心，假设 另两个实体都只有一个实例：
若中心实体只有一个实例能与另两个 实体的一个实例进行关联，则中心实体的 连通数为`一`
若中心实体有多于一个实例能与另两 个实体实例进行关联，则中心实体的连通 数为`多`

![image-20240920164143317](https://s2.loli.net/2024/09/20/7BxRMdZ4nKwWakh.png)

* 以病房为中心
* 病人住在一个病房，医生管理一个病房
* 所以病房端是1
* 以病人为中心，一个病房住多个病人，一个医生也治疗多个病人
* 有一端是多，就是多，所以病人是n
* 以医生为中心，一个病房对应一个医生，但是一个病人对应多个医生
* 有一端是多，就是多，所以医生是m
* 整体来说，表示一个病房有多个病人和多个医生，一个医生值负责一个病房，一个病人只属于一个病房。

![image-20240920164731529](https://s2.loli.net/2024/09/20/wZ3U6svfBKJSgQ8.png)

* 供应商，项目，零件
* 表示供应 商为多个项目供 应多种零件，每 个项目可用多个 供应商供应的零 件，每种零件可 由不同的供应商 供应。

#### 同一个实体集内的二元联系

![image-20240920165152107](https://s2.loli.net/2024/09/20/xHQjFUMORLA4KDw.png)

* 主队和客队都属于球队



### 扩展的E-R模型（弱实体，特殊化，聚集）

* 弱实体：在现实世界中有一种特殊的依赖联系，该联系是指某实体是否存在对于另 一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，而将这 类实体称为弱实体，如家属与职工的联系，附件与邮件。
* 用两个嵌套的矩形表示

![image-20240920165358014](https://s2.loli.net/2024/09/20/wiGn5VLAZxKX6oe.png)

* 特殊化：在现实世界中，某些实体一方面具有一些共性，另一方面还具有各自的特 性，一个实体集可以按照某些特征区分为几个子实体。
* 用圈联系，用两条平行线联系

![image-20240920165525217](https://s2.loli.net/2024/09/20/3A5XsarHmWI9MGP.png)

* 聚集：一个联系作为另一个联系的一端。

![image-20240920165646737](https://s2.loli.net/2024/09/20/IA1Jqe6UadtmvQZ.png)



## 4.逻辑结构设计

### 考点1：关系模式相关概念

* 属于数据模型的一种

* 数据模型包括：层次，网状，关系，面向对象模型
* 数据模型三要素：数据结构，数据操作，数据的约束条件

* 关系模式：二维表，属性为列名

#### 关系模式概念

* 目或度：关系模式中属性的个数。
* 候选码：候选键，唯一标识元组，且无冗余，可以是属性的集合（包含一个或多个属性）
* 对于`学生（学号，姓名，身份证号）` 来说，若将`学号，身份证号`确定为候选码，则出现冗余。因为单独得学号或是身份证号就可以作为候选码，正确的候选码应该是有两个：学号或是身份证号。
* 可以从候选键中选择一个作为主码（键）
* 主属性：组成候选码的属性就是主属性，其他的就是非主属性。
* 外码（外键）：其他关系的主键。
  * 例如：成绩（学号，分数），学号是学生的主键，也是成绩的外键。
* 全码（ALL-key）：关系模式的所有属性组是这个关系的候选码。

#### 关系模式的3种类型

* 基本关系
* 查询表
* 视图表

#### 完整性约束

* 实体完整性约束：主键唯一，非空
* 参照完整性约束：外键要么是其他关系的主键，要么是空
* 用户自定义完整性约束
* 触发器：完成一些复杂的完整性约束的设定，针对某种事件进行监听。

### 考点2：E-R图转关系模式⭐

![image-20240921143054807](https://s2.loli.net/2024/09/21/pmz2LqRJgDAcEds.png)

联系转成关系模式：

* 一对一的联系，转换有两种方式
  * 独立的关系模式：并入两端主键及联系自身属性。（主键：任一端主键）
  * 归并（任意一端）：并入**多端**主键及联系自身属性。（主键：保持不变）
* ![image-20240921144235789](https://s2.loli.net/2024/09/21/GMIa7DgscLTJk1b.png)
  * 不是任意归并，而是归并到多的一端
* ![image-20240921144348976](https://s2.loli.net/2024/09/21/D2h6BqRmEcVbxdN.png)

题：一对一

![image-20240921144454449](https://s2.loli.net/2024/09/21/ud7Msa3z6wgYe8P.png)

对于一对一关系“任职”来说

转为单独的关系模式：

![image-20240921144615140](https://s2.loli.net/2024/09/21/uEWqphBxgkYAvS7.png)

并入：关系“任职”并入到校长关系中，同时并入另一端关系的主键“校名”

![image-20240921144715504](https://s2.loli.net/2024/09/21/w4bPMrEAQ518pVk.png)

题：一对多

![image-20240921144858587](https://s2.loli.net/2024/09/21/7Gj2kBafXiDwTCp.png)

独立的关系模式：**以多端的主键作为自身的主键**

![image-20240921144957069](https://s2.loli.net/2024/09/21/WE12nw4kSCVYMgm.png)

并入到多端（账户）：

![image-20240921145240417](https://s2.loli.net/2024/09/21/fGpRAbLXZENYmvP.png)



题：多对多

![image-20240921150134754](https://s2.loli.net/2024/09/21/dNxkRIt18CYgcZU.png)

单独作为一个关系：主键由两端的主键组成

![image-20240921150201800](https://s2.loli.net/2024/09/21/Rk3eKtyiP7ozUhG.png)

总结：考试以二元联系为主

![image-20240921150558108](https://s2.loli.net/2024/09/21/NmEeJTyZcbaGvsA.png)



## 5.关系代数

对于一个关系表，

* 垂直为属性列，称为目、度。
* 水平为元组行，记录、实例。

![image-20240921151051301](https://s2.loli.net/2024/09/21/XG3kNTx1MuK8yhj.png)

![image-20240921151205206](https://s2.loli.net/2024/09/21/MvIbdgnVQuzwlaG.png)

差：S1 - S2和 S2 - S1是不一样的，减去的是两个关系的交集

### 笛卡尔积X

![image-20240921152229001](https://s2.loli.net/2024/09/21/Vslny6L823vkNfo.png)

* 属性列数：两者之和
* 元组个数：两者之积，排列组合

### 投影Π

垂直方向选择数据，会修改表结构

![image-20240921153551316](https://s2.loli.net/2024/09/21/Z5CN2a3LlPvRoKe.png)

### 选择 

水平方向选择数据，不会修改表结构

直接根据列名进行筛选

![image-20240921153656943](https://s2.loli.net/2024/09/21/tAPb4klS9BHI3FE.png)

或是根据两个列之间值相同来筛选，例如，对于S1XS2

![QianJianTec1726904610076](https://s2.loli.net/2024/09/21/QAaze1HRoIbvnV5.png)

选择第一列和第四列值相同的元组



### 自然连接

* 属性列数：二者之和 - 重复列数

* 元组行数：同名属性列取值相等

![image-20240921153751672](https://s2.loli.net/2024/09/21/JREPnltXOcv9fr1.png)

### 选择与投影的先后关系

![image-20240921155054181](https://s2.loli.net/2024/09/21/BevSbO6VfnDKq4I.png)



![QianJianTec1726904748559](https://s2.loli.net/2024/09/21/jQvaUT4PJeD95AN.png)

与自然连接$$S1\Join S2$$等价

![QianJianTec1726904789335](https://s2.loli.net/2024/09/21/PkxKbZVRc3nCrGY.png)

与自然连接$$S1\Join S2$$ 不等价

规则：

* 尽可能的先压缩
* 性能最优
  * 两侧运算对象，运算表格尽可能小

例题

![image-20240921155710740](https://s2.loli.net/2024/09/21/7uF1KYvViTc6hjM.png)

> CB

对于D选项的 `2 > ‘7’` 单引号的7不代表第七列，而是值7

![image-20240921161751697](https://s2.loli.net/2024/09/21/rp3AuZijSNzal5q.png)

> D 先按条件筛选，缩小后再进行笛卡尔积



## 6.规范化理论

### 考点1：规范化理论基本概念⭐

#### 函数依赖

![image-20240921163532424](https://s2.loli.net/2024/09/21/kTEPMfbt2Zd1vX3.png)

* X为决定因素，Y是被决定因素

![image-20240921164828736](https://s2.loli.net/2024/09/21/2MOxNFRm5SdXHB9.png)

#### 部分函数依赖

> 如果在一个关系模式中，一个属性集合X（非候选键）函数依赖于候选键的一部分，而不是整个候选键，那么我们就说X对候选键有部分函数依赖。这意味着候选键的一部分属性就足以确定X的值，而不是整个候选键。

举例说明

假设有一个关系模式 **学生选课表（StudentCourse）**，包含以下属性：

- **学生ID（StudentID）**：主键的一部分
- **课程ID（CourseID）**：主键的一部分
- **学生姓名（StudentName）**
- **课程名称（CourseName）**
- **教师姓名（TeacherName）**

在这个例子中，**主键**是 **(StudentID, CourseID)**，即复合主键。

分析各属性的依赖关系：

1. **学生姓名（StudentName）** 只依赖于 **学生ID**，即 **StudentID → StudentName**。
2. **课程名称（CourseName）** 和 **教师姓名（TeacherName）** 只依赖于 **课程ID**，即 **CourseID → CourseName, TeacherName**。

这里，**StudentName**、**CourseName** 和 **TeacherName** 都是**非主属性**，并且它们分别只依赖于主键的一部分（**StudentID** 或 **CourseID**）。这就形成了**部分函数依赖**。

#### Amstrong公理体系

![image-20240921164924534](https://s2.loli.net/2024/09/21/3jQy4IK7evgWkps.png)

![image-20240921165045067](https://s2.loli.net/2024/09/21/Tqc7x9Atva63F4Y.png)

#### 候选键⭐

> 唯一标识元组，无冗余

从候选键中任选一个，为主键

若某个属性的闭包包含所有的结点，则该属性结点为候选键。

如果 A的闭包 包含了关系中的所有属性，那么 A 是候选关键字。

![image-20240921170128067](https://s2.loli.net/2024/09/21/wUFIBtxvnL5Cohr.png)

![image-20240922114933685](https://s2.loli.net/2024/09/22/oDxBrtSi6EhXq3N.png)

> A  A1结点入度为零，从A1结点出发，可以遍历所有结点

![image-20240922115336009](https://s2.loli.net/2024/09/22/E9oJSbzpd8Fqvx5.png)

第一步：先找到所有入度为0的结点

第二步：看这些结点构成的集合是否可以找到全部其他结点（入度不为0的结点）

> 答案为ABCD
>
> tips: `A和B` 与 `AB` 不一样。`A和B` 代表两个候选键， `AB` 代表复合属性，组合键。

对应图示：

![image-20240922115854159](https://s2.loli.net/2024/09/22/hLXiyKusWx329Pe.png)

![image-20240922115959293](https://s2.loli.net/2024/09/22/pBohFtXRxUlgqLi.png)

> 选B： A的闭包包含所有结点，B的闭包也包含所有节点。

#### 主属性与非主属性

![image-20240922122410106](https://s2.loli.net/2024/09/22/vYNpeZ85VS6jbR3.png)

* 这里的ST虽然入度为0，但是它没有单独的函数依赖，只能和CITY一起形成组合键。所以候选码的一种情况是（CITY, ST）
* 第二种候选键：（ST,ZIP），通过ZIP推出CITY
* 所以该关系模式CSZ的主属性为（CITY, ST, ZIP），没有非主属性

![image-20240922123031760](https://s2.loli.net/2024/09/22/jocW3uXMnUxqkdS.png)

> B

![image-20240922123259968](https://s2.loli.net/2024/09/22/ED5aGjkJz62e9uO.png)

> AC

![image-20240922123531288](https://s2.loli.net/2024/09/22/wcLvDs9Nhu7i6qa.png)

> 注意题目内容是“伪传递律”。选B
>
> C为传递律，D为增广律，A为合并律





### 考点2：范式判断⭐

![image-20240922125313655](https://s2.loli.net/2024/09/22/cURI5lin3aNtSB7.png)

> 数据库范式是关系数据库设计中用于减少数据冗余和提高数据完整性的标准。

若没有达到第三范式，即可回答“数据冗余、修改异常、插入异常、删除异常、数据不一致”。

#### 第一范式

![image-20240922130035887](https://s2.loli.net/2024/09/22/p6YZibEw1HR8rqv.png)

> “总和”为派生属性

#### 第二范式

![image-20240922130735821](https://s2.loli.net/2024/09/22/JIMda2w8YuvLZyr.png)

* 找候选键：（学号，课程号）
* 找非主属性：成绩，学分
* 判断是否存在非主属性对候选键的部分函数依赖，存在，课程号➡学分，所以达不到2NF
* 所以，将这个部分函数依赖分割出来，但保持函数依赖并能够还原
  * （课程号，学分）
  * （学号，课程号，成绩）
* 分割后，能达到第二范式

#### 第三范式

![image-20240922132618625](https://s2.loli.net/2024/09/22/SmjGboDqELcPKfR.png)

![image-20240922132728211](https://s2.loli.net/2024/09/22/Bg4lP7LHEM5RqbX.png)

* 学号 ➡ 姓名，系号
* 系号 ➡ 系名，系位置
* **属于单属性候选键，这种情况的关系至少为2NF**
* 因为存在非主属性传递式依赖于主属性，学号➡系号➡系名，所以不满足3NF
* 对表格进行拆分，使拆分后的，满足3NF
  * （**系号**，系名，系位置），（**学号**，姓名，系号）

#### BC范式

> BC范式（BCNF）：设R是一个关系模式，F是它的依赖集，R属于 BCNF当且仅当其F中每个依赖的决定因素必定包含R的某个候选码

![image-20240922163603750](https://s2.loli.net/2024/09/23/1TMp5blF4kENnh6.png)

* 每个老师只教一门课程—— T→J
* 某一学生选某门课，就对应一个固定老师——SJ→T
* 函数依赖集合：{T→J, SJ→T}
* 找候选键：SJ, ST
* **没有非主属性，至少满足3NF**
* 判断是否符合BC范式
* 查看函数依赖集合：{T→J, SJ→T}，决定因素分别为T, SJ
* 决定因素T没有包含任何一个候选键{SJ, ST}
* 决定因素SJ包含候选键 SJ
* 所以，**不满足BC范式**，规范度最高为3NF

![image-20240922164605276](https://s2.loli.net/2024/09/23/MIGoh8b6HgluC92.png)



#### 判断范式的过程

> 层层递进

![image-20240922164727824](https://s2.loli.net/2024/09/23/xgvlNrwW83mDXs7.png)

![image-20240922165032200](https://s2.loli.net/2024/09/23/iJa958vELTOR1bn.png)

![image-20240922165200383](https://s2.loli.net/2024/09/23/ycbNtT56mdYRnKD.png)

> 我的答案：BAD

> 正确答案：BCC

> 4NF为多值函数依赖，不是考试范围，和BC范式不一样





### 考点3：模式分解

#### 保持函数依赖分解

* 设数据库模式ρ={R1，R2，，Rk} 是关系模式R的一个分解，F 是R上的函数依赖集，ρ中每个模式Ri上的FD集是Fi。如果[F1, F2，…，Fk)与F是**等价**的（即相互逻辑蕴涵），那么称分解ρ保持FD。
* 对于**等价**来说，冗余函数依赖不需要保留
* **属性存在时，对应的函数依赖随着属性也被保留**

例:设关系模式R （U,F)，其中U=[A，B，C，D，E); F={A→BC,C→D, BC→E, E→A), 则分解ρ=(R1(ABCE), R2(CD)) 是否保持函数依赖？而分解ρ=[R1(ABE)，R2(CD)是否保持函数依赖?

> 保持。没保持。

分解ρ={R1(ABC), R2(BCE), R3(CD)}, 是否保持函数依赖？

> 不保持。
>
> 没有E→A

例: 设关系模式R (U,F) ,其中U=A,B,C),F={A→B,B→C, A→C)，则分解ρ=[R1(AB)，R2(BC))是否保持函数依赖?

> 保持。
>
> R1的函数依赖： A→B
>
> R2的函数依赖： B→C
>
> 虽然看起来没有A→C的函数依赖，但是可以由A→B和 B→C推导出，也可以得出**A→C为冗余函数依赖**。



#### 无损分解

无损连接分解：指将一个关系模式分解成若干个关系模式后，通过 **自然连接**等运算仍能还原到原来的关系模式。

![image-20240923125145209](https://s2.loli.net/2024/09/23/VGo3qZ4cbiglIQX.png)

* 先找到候选键：（学号，课程号）

* 达到了1NF

* ![image-20240923125423039](https://s2.loli.net/2024/09/23/8yV3ZINsQa5t1KH.png)

* 查看分解后，是否保持函数依赖

* 判断是否为无损分解，通过对分解后的关系进行还原来判断

* 两个子关系想要合并还原，必须存在同名属性列，并且**以该属性列为左侧决定因素的函数依赖**保留下来

  > 例如：
  >
  > 成绩（学号，课程号，分数）
  >
  > 学生（学号，姓名）
  >
  > 有同名属性列**课程号**，并且**以该属性列为左侧决定因素的函数依赖**保留下来，为`学号→姓名`
  >
  > 合并后为：成绩（学号，课程号，分数，姓名）

* 还原与之对应的决定性因素

* ![image-20240923133836120](https://s2.loli.net/2024/09/23/5BcKnqts2M3D8jF.png)

* ![image-20240923141057017](https://s2.loli.net/2024/09/23/p2Swe4s9aCnkoI5.png)

#### 表格法

![image-20240923141314711](https://s2.loli.net/2024/09/23/3JAZadumVz2Fjpx.png)

* 查看同名属性列，如：成绩和学生的学号，在学生关系中，学号决定姓名，所以成绩和学生合并后，可以有（学号，姓名，课程号，分数）
* 依次继续进行，直到所有属性均被包含
* 则说明存在一种还原方式，将所有属性全部还原出来

![image-20240923143959240](https://s2.loli.net/2024/09/23/pO3j8MDoAvtm7BK.png)

> ρ1是，保持函数依赖，且无损
>
> ρ2不是，保持了函数依赖，无法还原，有损

用表格法求解：

![image-20240923144226541](https://s2.loli.net/2024/09/23/NIRisdDu2lbVYPy.png)

若分解ρ3 = {R1(A), R2(BC)}，不保持函数依赖，且有损

例：设R=ABCD,F=[A→B, B→C, C→D}, 则分解ρ1={R1(ABD), R2(BC)}是否都为无损分解？

> 不保持函数依赖，无损



#### 公式法

![image-20240923145036648](https://s2.loli.net/2024/09/23/5JCvn8uKXDLo6kg.png)

![image-20240923145308658](https://s2.loli.net/2024/09/23/8S7k9tHsvFCbK3i.png)

> ρ1无损，ρ2有损

![image-20240923145415050](https://s2.loli.net/2024/09/23/7rkJqz9XoaHyGPW.png)

> D
>
> D 不保持函数依赖，但是无损 最接近的答案



## 7.SQL语言

### 考点1：普通查询⭐

![image-20240923150520284](https://s2.loli.net/2024/09/23/T12sRCp5UVKrAN9.png)

![image-20240923150559777](https://s2.loli.net/2024/09/23/erdCEw38WflTRkG.png)

```sql
SELECT *
FROM S,R  -- S,R表示S与R的笛卡尔积
WHERE S.Sno = R.Sno
ORDER BY 列名 ASC|DESC ; -- ASC升序 DESC 降序
```

![image-20240923151820932](https://s2.loli.net/2024/09/23/jtGARNJPmn5ZhU1.png)

> 关系R和关系S去掉重复元素，为：A, B, C, D, E, F, G 标号为1，2，3，4，5，……
>
> A
>
> C



### 考点2：分组查询

```SQL
GROUP BY 列名1 
[HAVING <条件表达式>]
```

![image-20240923162318953](https://s2.loli.net/2024/09/23/fQvTkDMBlcwKEhV.png)

> 关于COUNT:
>
> DISTINCT是不含重复信息的意思

关于HAVING语句

* 与 `WHERE` 子句不同，`WHERE` 是在分组前对行进行过滤，而 `HAVING` 则是在分组后对聚合结果进行过滤。

* ```
  HAVING SUM(Amount) > 1500;
  ```
  
* 注意，`WHERE` 子句无法实现这一点，因为 `WHERE` 在分组前应用，无法使用聚合函数。

* **顺序**：`HAVING` 子句必须出现在 `GROUP BY` 子句之后。

![image-20240923162948625](https://s2.loli.net/2024/09/23/SFY6i7vyQUzTaeC.png)

> A
>
> D
>
> C









### 考点3：权限控制

![image-20240923163847382](https://s2.loli.net/2024/09/23/Age6LctTUniIROa.png)





![image-20240923164046075](https://s2.loli.net/2024/09/23/7fLJmbTaF6cpYo4.png)

> C



## 8.并发控制（1到2分）

### 考点1：事务的特性

**ACID**

![image-20240923164939484](https://s2.loli.net/2024/09/23/RLPTly6vdVQFnKM.png)

* 成功提交，指写入日志
* 事务之间是并发的
* 并发产生的问题：丢失更新；不可重复读问题；读脏数据

![image-20240923165241456](https://s2.loli.net/2024/09/23/3UQSOvjVJWcCGgR.png)

> D







### 考点2：并发问题(考的少)

#### 丢失更新，修改

![image-20240923165425716](https://s2.loli.net/2024/09/23/jM8YkBJuXP7HaWq.png)

多次写回，导致第一次写回的结果被覆盖

#### 不可重复读

![image-20240923165630413](https://s2.loli.net/2024/09/23/Inu1SBsVjcK8mrh.png)

两次读到的A值不一样

#### 读脏数据

![image-20240923165802682](https://s2.loli.net/2024/09/23/JDRLo5lwt4jzYf7.png)

读之后发生回滚，读到的数据就是脏数据



### 考点3：封锁协议

![image-20240923170451948](https://s2.loli.net/2024/09/23/Tdi5JYSWyx1MKab.png)

* 共享锁/S锁/读锁：若事务T对数据对象A加上S锁， 其他事务只能对A再加S 锁，不能再对A添加X锁。 

* 排他锁/独占锁/X锁/写锁： 若事务T对数据对象A加 上X锁，其他事务不能再 对A添加任意锁。
* 加锁，就涉及到死锁问题，预防，解除

![image-20240923170747459](https://s2.loli.net/2024/09/23/6WpiI48rZHu7lCA.png)

> 我的答案B

> 正确答案D



## 9.总结

